"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;var builders=_interopRequireWildcard(require("./assertions/builders")),_types=require("./assertions/types"),_utils=require("./utils");function _getRequireWildcardCache(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;_getRequireWildcardCache=function(){return e};return e}function _interopRequireWildcard(e){if(e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=_getRequireWildcardCache();if(t&&t.has(e))return t.get(e);var s={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var r in e)if(Object.prototype.hasOwnProperty.call(e,r)){var n=i?Object.getOwnPropertyDescriptor(e,r):null;n&&(n.get||n.set)?Object.defineProperty(s,r,n):s[r]=e[r]}s.default=e;t&&t.set(e,s);return s}const ASYNC=Symbol("cache of async setting"),ERRORS=Symbol("cache of all errors as they occurred during validation"),REFS=Symbol("cache of all referenced schemas in current schema"),VALIDATE=Symbol("validates schema"),ASSIGN_SCHEMA=Symbol("assigns schema definitions to the class instance"),ASSIGN_REF=Symbol("assigns a ref to ref cache"),ASSIGN_REFS=Symbol("assigns a Hash of refs to ref cache"),ASSIGN_OPTIMIZED=Symbol("assigns schema optimizations and/or references"),ASSERT_SCHEMA=Symbol("validates schema types"),ASSERT_REF=Symbol("validates schema $ref"),ASSERT_REF_ABSOLUTE=Symbol("validates schema $ref with absolute URLs"),ASSERT_REF_RELATIVE=Symbol("validates schema $ref with relative URLs"),ASSERT_REF_POINTER=Symbol("validates schema $ref with JSON pointers"),ASSERT_TYPE=Symbol("validates Schema type arrays"),enumerable=!0;class Schema{constructor(e=!1){Object.defineProperties(this,{[ASYNC]:{value:e},[ERRORS]:{value:[]},[REFS]:{value:{}}});e?Object.defineProperty(this,"validate",{value:async(e,t)=>this[VALIDATE](e,t)}):Object.defineProperty(this,"validate",{value:(e,t)=>this[VALIDATE](e,t)})}get errors(){return[...this[ERRORS]]}get isAsync(){return this[ASYNC]}async assign(e,t){(0,_types.isObject)(t)&&await this[ASSIGN_REFS](t);this[ASSIGN_SCHEMA](this,e);const s=e.$id||e.id;(0,_types.isString)(s)&&Object.defineProperty(this[REFS],s,{value:this,enumerable:true});await this[ASSIGN_OPTIMIZED](this);Object.freeze(this[REFS]);return this}[VALIDATE](e,t=this){this[ERRORS].length=0;if(!1===t)this[ERRORS].push("'false' JSON Schema invalidates all values");else if(t[_types.OPTIMIZED]){this[ERRORS].push(t[_types.OPTIMIZED](e,t));this[ERRORS][this[ERRORS].length-1]||this[ERRORS].pop()}return!this[ERRORS].length}[ASSIGN_SCHEMA](e,t){if(!(0,_types.isObject)(t))throw new TypeError("JSON Schemas must be an object at root");const assign=(e,t,s=[])=>{const i=Object.keys(t);let r=i.length;for(;r--;){const n=t[i[r]];n&&"object"==typeof n?Object.defineProperty(e,i[r],{value:(0,_types.isArray)(n)?assign([],n,[...s,i[r]]):assign({},n,[...s,i[r]]),enumerable:true}):Object.defineProperty(e,i[r],{value:n,enumerable:true})}const n=t.$id||t.id;(0,_types.isString)(n)&&(0,_types.isSubSchema)(n,s)&&Object.defineProperty(this[REFS],n,{value:e,enumerable:true});return e};assign(e,t)}async[ASSIGN_REF](e,t){Object.defineProperty(this[REFS],e,{value:{},enumerable:true});this[ASSIGN_SCHEMA](this[REFS][e],t);return this[ASSIGN_OPTIMIZED](this[REFS][e])}async[ASSIGN_REFS](e){const t=Object.keys(e);let s=t.length;for(;s--;)await this[ASSIGN_REF](t[s],e[t[s]])}async[ASSIGN_OPTIMIZED](e){const t=e.$id||e.id,assign=async(s,i=[])=>{if((0,_types.isObject)(s)&&!(0,_types.isParentKeyword)(i)){const{$id:r,$ref:n,id:a}=s,o=[];let S;if((0,_types.isUndefined)(n)){o.push(this[ASSERT_SCHEMA](s));const n=r||a;(0,_types.isUndefined)(n)||n===t||o.push(...await this[ASSERT_REF](n,e,i))}else o.push(...await this[ASSERT_REF](n,e,i));if(o.length){S=1===o.length?o.pop():(e,t)=>{let s,i=o.length;for(;i--;){s=o[i](e,t);if(s)return s}};Object.defineProperty(s,_types.OPTIMIZED,{value:S});Object.freeze(s[_types.OPTIMIZED])}}const r=Object.keys(s);let n=r.length;for(;n--;){const e=s[r[n]];e&&"object"==typeof e&&await assign(e,[...i,r[n]])}return Object.freeze(s)};return assign(e)}async[ASSERT_REF](e,t,s){if(!(0,_types.isString)(e))throw new TypeError("#$ref: must be a string");if((0,_types.isPathFragment)(e))return[];const i=(0,_types.isRef)(e);if((0,_types.isNull)(i))throw new SyntaxError("#$ref: is malformed");let r={};r="#"===e[0]?this[ASSERT_REF_POINTER](i[0].split("#")[1],t):i[1]&&i[2]?await this[ASSERT_REF_ABSOLUTE](i):await this[ASSERT_REF_RELATIVE](i,t,s);const{referred:n,fn:a}=r;return a&&(0,_types.isObject)(n)?[e=>a(e,n)]:!1===n?[()=>"'false' JSON Schema invalidates all values"]:[]}async[ASSERT_REF_ABSOLUTE](e){const t=e[0].split("#")[0],s="https"===e[2];let i=this[REFS][t];if((0,_types.isUndefined)(i)){const e=await(0,_utils.getSchema)(t,s);i=await this[ASSIGN_REF](t,e)}if(-1!==e[3].indexOf("#"))return this[ASSERT_REF_POINTER](e[3].split("#")[1],i);return{referred:i,fn:this[ASSERT_SCHEMA](i)}}async[ASSERT_REF_RELATIVE](e,t,s){let i;(0,_types.isString)(t.$id)?i=(0,_types.isRef)(t.$id):(0,_types.isString)(t.id)&&(i=(0,_types.isRef)(t.id));let r=i[1],n=t;for(let e=0,t=s.length;e<t;e++){n=n[s[e]];(0,_types.isString)(n.$id)&&(0,_types.isPathFragment)(n.$id)?r=`${r}${n.$id}`:(0,_types.isString)(n.id)&&(0,_types.isPathFragment)(n.id)&&(r=`${r}${n.id}`)}i[0]=`${r}${e[0]}`;i[3]=`${e[0]}`;return this[ASSERT_REF_ABSOLUTE](i)}[ASSERT_REF_POINTER](e,t){const traverse=e=>{const s=e.split("/");let i=t;s.shift();if(s.length)for(let e=0,t=s.length;e<t;e++)i=i[s[e].replace(/~1/g,"/").replace(/~0/g,"~")];return i.$ref?traverse(i.$ref.split("#")[1]):i},s=traverse(e);return{referred:s,fn:this[ASSERT_SCHEMA](s)}}[ASSERT_SCHEMA](e){const t=[];(0,_types.isUndefined)(e.type)||t.push(...this[ASSERT_TYPE](e));t.push(...builders.AssertGeneric.optimize(e));t.push(...builders.AssertBoolean.optimize(e));t.push(...builders.AssertNull.optimize(e));t.push(...builders.AssertNumber.optimize(e));t.push(...builders.AssertString.optimize(e));t.push(...builders.AssertArray.optimize(e));t.push(...builders.AssertObject.optimize(e));t.push(...builders.AssertLogical.optimizeAllOf(e));t.push(...builders.AssertLogical.optimizeAnyOf(e));t.push(...builders.AssertLogical.optimizeNot(e));t.push(...builders.AssertLogical.optimizeOneOf(e));return 1===t.length?t.pop():(e,s)=>{let i,r=t.length;for(;r--;){i=t[r](e,s);if(i)return i}}}[ASSERT_TYPE](e){const{type:t}=e;if((0,_types.isString)(t)){if(!(0,_types.isSchemaType)(t))throw new ReferenceError(`#type: '${t}' is not a valid JSON Schema type`);return[]}if((0,_types.isArray)(t)){if(!(0,_types.isEnum)(t,_types.isSchemaType))throw new TypeError("#type: type arrays must contain only string");const e=t.map((e=>this[ASSERT_SCHEMA]({type:e})));return[(t,s)=>{let i=e.length;for(;i--;)if(!e[i](t,s))return;return"#type: value does not match the List of types"}]}throw new TypeError("#type: must be either a valid type string or list of strings")}}var _default=new Proxy(Schema,{construct:async function(e,t){return(0,_types.isUndefined)(t[0])||(0,_types.isBoolean)(t[0])?new e(t[0]):(0,_types.isBoolean)(t[1])?new e(t[1]).assign(t[0]):new e(t[2]).assign(t[0],t[1])}});exports.default=_default;module.exports=exports.default;
