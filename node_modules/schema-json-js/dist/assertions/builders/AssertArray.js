"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;var _types=require("../types");const ASSERT_CONTAINS=Symbol("validates array contains item"),ASSERT_ITEMS=Symbol("validates array items");class AssertArray{constructor(){return AssertArray}static optimize(e){const{type:t,items:s,additionalItems:i,contains:a,maxItems:n,minItems:r,uniqueItems:m}=e;(0,_types.isUndefined)(s)||AssertArray[ASSERT_ITEMS](e);(0,_types.isUndefined)(a)||AssertArray[ASSERT_CONTAINS](a);(0,_types.isUndefined)(n)||(0,_types.assertSizeMax)(n,"maxItems");(0,_types.isUndefined)(r)||(0,_types.assertSizeMin)(r,"minItems");return s||!1===s||i||a||!1===a||m?[(e,t)=>{if(!(0,_types.isArray)(e))return"array"===t.type?"#type: value is not an array":void 0;const s=e.length,i=new Set;let a,n=!1;if("number"==typeof t.maxItems&&s>t.maxItems)return"#maxItems: value maximum exceeded";if("number"==typeof t.minItems&&s<t.minItems)return"#minItems: value minimum not met";for(let r=0;r<s;r++){t.uniqueItems&&(e[r]&&"object"==typeof e[r]?i.add(JSON.stringify(e[r])):i.add(e[r]));if(t.items||!1===t.items)if((0,_types.isArray)(t.items)){if(r<t.items.length){if(!1===t.items[r])return"#items: 'false' JSON Schema invalidates all values";if(t.items[r][_types.OPTIMIZED]){a=t.items[r][_types.OPTIMIZED](e[r],t.items[r]);if(a)return a}}else if(t.additionalItems||!1===t.additionalItems){if(!1===t.additionalItems)return`#additionalItems: '${r}' additional items not allowed`;if(t.additionalItems[_types.OPTIMIZED]){a=t.additionalItems[_types.OPTIMIZED](e[r],t.additionalItems);if(a)return a}}}else{if(!1===t.items)return"#items: 'false' JSON Schema invalidates all values";if(t.items[_types.OPTIMIZED]){a=t.items[_types.OPTIMIZED](e[r],t.items);if(a)return a}}if(t.contains||!1===t.contains)if(n)r===s-1&&(n=!1);else{!1===t.contains?a="#contains: 'false' JSON Schema invalidates all values":t.contains[_types.OPTIMIZED]&&(a=t.contains[_types.OPTIMIZED](e[r],t.contains));if(a){n=!1;if(r===s-1)return"#contains: value does not contain element matching the schema"}else n=!0}}return 0!==s||!t.contains&&!1!==t.contains?t.uniqueItems&&s!==i.size?"#uniqueItems: value does not contain unique items":void 0:"#contains: value does not contain element matching the schema"}]:n||r?[(e,t)=>(0,_types.isArray)(e)?"number"==typeof t.maxItems&&e.length>t.maxItems?"#maxItems: value maximum exceeded":"number"==typeof t.minItems&&e.length<t.minItems?"#minItems: value minimum not met":void 0:"array"===t.type?"#type: value is not an array":void 0]:"array"===t?[(e,t)=>{if(!(0,_types.isArray)(e))return"#type: value is not an array"}]:[]}static[ASSERT_CONTAINS](e){if(!(0,_types.isSchema)(e))throw new TypeError("#contains: keyword should be a JSON Schema")}static[ASSERT_ITEMS](e){const{items:t,additionalItems:s}=e;if((0,_types.isArray)(t)){if(!(0,_types.isUndefined)(s)&&!(0,_types.isBoolean)(s)&&!(0,_types.isObject)(s))throw new TypeError("#additionalItems: must be either a JSON Schema or boolean if defined")}else if(!(0,_types.isSchema)(t))throw new TypeError("#items: must be either a JSON Schema or an array of JSON Schemas")}}exports.default=AssertArray;module.exports=exports.default;
