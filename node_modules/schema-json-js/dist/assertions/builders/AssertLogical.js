"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;var _types=require("../types");class AssertLogical{constructor(){return AssertLogical}static optimizeAllOf(e){const{allOf:t}=e;if((0,_types.isUndefined)(t))return[];if(!(0,_types.isArray)(t)||!(0,_types.isTypedArray)(t,_types.isSchema))throw new TypeError("#allOf: keyword should be an array of JSON Schemas");return[(e,t)=>{let r;for(let s=0,n=t.allOf.length;s<n;s++){if(!1===t.allOf[s])return"#allOf: 'false' JSON Schema invalidates all values";if(t.allOf[s][_types.OPTIMIZED]){r=t.allOf[s][_types.OPTIMIZED](e,t.allOf[s]);if(r)return r}}}]}static optimizeAnyOf(e){const{anyOf:t}=e;if((0,_types.isUndefined)(t))return[];if(!(0,_types.isArray)(t)||!(0,_types.isTypedArray)(t,_types.isSchema))throw new TypeError("#anyOf: keyword should be an array of JSON Schemas");return[(e,t)=>{for(let r=0,s=t.anyOf.length;r<s;r++){if(!0===t.anyOf[r])return;if(t.anyOf[r][_types.OPTIMIZED]&&!t.anyOf[r][_types.OPTIMIZED](e,t.anyOf[r]))return}return"#anyOf: none of the defined JSON Schemas match the value"}]}static optimizeNot(e){const{not:t}=e;if((0,_types.isUndefined)(t))return[];if(!(0,_types.isSchema)(t))throw new TypeError("#not: keyword should be a JSON Schema");return[(e,t)=>{if(!(!1===t.not||t.not[_types.OPTIMIZED]&&t.not[_types.OPTIMIZED](e,t.not)))return"#not: value validated successfully against the schema"}]}static optimizeOneOf(e){const{oneOf:t}=e;if((0,_types.isUndefined)(t))return[];if(!(0,_types.isArray)(t)||!(0,_types.isTypedArray)(t,_types.isSchema))throw new TypeError("#oneOf: keyword should be an array of JSON Schemas");return[(e,r)=>{const s=t.length;let n=1;for(let t=0;t<s;t++)(!1===r.oneOf[t]||r.oneOf[t][_types.OPTIMIZED]&&r.oneOf[t][_types.OPTIMIZED](e,r.oneOf[t]))&&n++;if(n!==s)return"#oneOf: value should match only one of the listed schemas"}]}}exports.default=AssertLogical;module.exports=exports.default;
