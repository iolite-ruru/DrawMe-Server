"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;var _types=require("../types");const ASSERT_DEPENDENCIES=Symbol("valiates object dependencies"),ASSERT_KEYS=Symbol("validates object keys"),ASSERT_PROPERTIES=Symbol("validates object properties"),ASSERT_REQUIRED=Symbol("validates object required");class AssertObject{constructor(){return AssertObject}static optimize(e){const{type:t,properties:r,patternProperties:s,additionalProperties:i,dependencies:p,required:n,maxProperties:o,minProperties:a,propertyNames:d}=e;let y={};(0,_types.isUndefined)(r)&&(0,_types.isUndefined)(s)&&(0,_types.isUndefined)(i)||(y=AssertObject[ASSERT_PROPERTIES](e));(0,_types.isUndefined)(p)||AssertObject[ASSERT_DEPENDENCIES](p);(0,_types.isUndefined)(d)||AssertObject[ASSERT_KEYS](d);const c=AssertObject[ASSERT_REQUIRED](n);(0,_types.isUndefined)(o)||(0,_types.assertSizeMax)(o,"maxProperties");(0,_types.isUndefined)(a)||(0,_types.assertSizeMin)(a,"minProperties");return r||s||i||!1===i||p||d||!1===d||n&&n.length?[(e,t)=>{if(!(0,_types.isObject)(e))return"object"===t.type?"#type: value is not an object":void 0;const r=Object.keys(e);let s,i=r.length,p=0,n=!1,o=!1;if("number"==typeof t.maxProperties&&i>t.maxProperties)return"#maxProperties: value maximum exceeded";if("number"==typeof t.minProperties&&i<t.minProperties)return"#minProperties: value minimum not met";for(;i--;){const a=e[r[i]];c[r[i]]&&p++;o=!1;if(t.properties&&(t.properties[r[i]]||!1===t.properties[r[i]])){o=!0;if(!1===t.properties[r[i]])return"#properties: 'false' JSON Schema invalidates all values";if(t.properties[r[i]][_types.OPTIMIZED]){s=t.properties[r[i]][_types.OPTIMIZED](a,t.properties[r[i]]);if(s)return s}}if(t.patternProperties){n=!1;const e=Object.keys(t.patternProperties);let p=e.length;for(;p--;)if(y[e[p]].test(r[i])){n=!0;if(!1===t.patternProperties[e[p]])return"#patternProperties: 'false' JSON Schema invalidates all values";if(t.patternProperties[e[p]][_types.OPTIMIZED]){s=t.patternProperties[e[p]][_types.OPTIMIZED](a,t.patternProperties[e[p]]);if(s)return s}}}if((t.additionalProperties||!1===t.additionalProperties)&&!o&&!n){if(!1===t.additionalProperties)return"#additionalProperties: additional properties not allowed";if(t.additionalProperties[_types.OPTIMIZED]){s=t.additionalProperties[_types.OPTIMIZED](a,t.additionalProperties);if(s)return s}}if(t.dependencies&&(t.dependencies[r[i]]||!1===t.dependencies[r[i]]))if(Array.isArray(t.dependencies[r[i]])){let s=t.dependencies[r[i]].length;for(;s--;)if(void 0===e[t.dependencies[r[i]][s]])return`#dependencies: value does not have '${r[i]}' dependency`}else{if(!1===t.dependencies[r[i]])return"#dependencies: 'false' JSON Schema invalidates all values";if(t.dependencies[r[i]][_types.OPTIMIZED]){s=t.dependencies[r[i]][_types.OPTIMIZED](e,t.dependencies[r[i]]);if(s)return s}}if(t.propertyNames||!1===t.propertyNames){if(!1===t.propertyNames)return"#propertyNames: 'false' JSON Schema invalidates all values";if(t.propertyNames[_types.OPTIMIZED]){s=t.propertyNames[_types.OPTIMIZED](r[i],t.propertyNames);if(s)return s}}}return t.required&&p!==t.required.length?"#required: value does not have all required properties":void 0}]:o||a?[(e,t)=>{if(!(0,_types.isObject)(e))return"object"===t.type?"#type: value is not an object":void 0;const r=Object.keys(e).length;return"number"==typeof t.maxProperties&&r>t.maxProperties?"#maxProperties: value maximum exceeded":"number"==typeof t.minProperties&&r<t.minProperties?"#minProperties: value minimum not met":void 0}]:"object"===t?[(e,t)=>{if(!(0,_types.isObject)(e))return"#type: value is not an object"}]:[]}static[ASSERT_DEPENDENCIES](e){const t=Object.keys(e);let r=t.length;for(;r--;){const s=e[t[r]];if(!((0,_types.isArray)(s)&&!s.length||(0,_types.isEnum)(s,_types.isString)||(0,_types.isSchema)(s)))throw new TypeError("#dependencies: all dependencies must either be JSON Schemas|enums")}}static[ASSERT_KEYS](e){if(!(0,_types.isSchema)(e))throw new TypeError("#propertyNames: must be a JSON Schema")}static[ASSERT_PROPERTIES](e){const{properties:t,patternProperties:r,additionalProperties:s}=e,i={};if(!(0,_types.isUndefined)(t)&&!(0,_types.isObject)(t))throw new TypeError("#properties: must be an object");if((0,_types.isObject)(r)){const e=Object.keys(r);let t=e.length;for(;t--;)i[e[t]]=new RegExp(e[t])}else if(!(0,_types.isUndefined)(r))throw new TypeError("#patternProperties: must be an object");if(!(0,_types.isUndefined)(s)&&!(0,_types.isSchema)(s))throw new TypeError("#additionalProperties: must be either a JSON Schema or boolean");return i}static[ASSERT_REQUIRED](e){if((0,_types.isUndefined)(e))return{};if(!(0,_types.isArray)(e)||!(0,_types.isTypedArray)(e,_types.isString))throw new TypeError("#required: required properties must be defined in an array of strings");return e.reduce(((e,t)=>{e[t]=!0;return e}),{})}}exports.default=AssertObject;module.exports=exports.default;
